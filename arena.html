<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BattleBillions ‚Äî Dual Live Battle</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;800&family=Orbitron:wght@600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --ink:#f5f5f5;
      --muted:#b7b7b7;
      --glass: rgba(20,20,24,.45);
      --gold:#ffd700;
      --gold-soft: rgba(255,215,0,.18);
    }

    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      color:var(--ink);
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:#000; /* 3D canvas sits on top */
      overflow:hidden;
    }

    /* 3D background canvas */
    #bg3d{
      position:fixed; inset:0; width:100%; height:100%; display:block;
      pointer-events:none;
      z-index:0;
      background:radial-gradient(1200px 800px at 30% 20%, #101012 0%, #000 70%);
    }

    /* Foreground container sits above canvas */
    .stream-container{
      position:relative; z-index:1;
      display:flex; height:100vh; width:100vw; gap:0;
    }
    .video-stream{
      flex:1; width:50%; height:100%; object-fit:cover; background:#000;
      filter: brightness(.92) contrast(1.12) saturate(1.12);
    }

    /* Top HUD */
    .top-bar{
      position:absolute; left:0; right:0; top:0; z-index:20; pointer-events:none;
      display:flex; justify-content:space-between; align-items:center; padding:10px 14px;
      background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0));
      backdrop-filter: blur(8px) saturate(120%);
    }
    .hud-chip{
      pointer-events:auto;
      display:inline-flex; align-items:center; gap:8px; padding:6px 12px; border-radius:999px;
      background:rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 8px 24px rgba(0,0,0,.25);
      font-size:12px; letter-spacing:.2px;
    }
    .hud-live{
      color:#000; background:linear-gradient(180deg,#ffe88a,#ffcc3b);
      box-shadow: 0 10px 28px rgba(255,215,0,.35);
      font-weight:800; font-family:Orbitron, sans-serif;
    }

    /* Opponent chip */
    .profile-labels{
      position:absolute; top:58px; right:20px; display:flex; gap:10px; z-index:22;
    }
    .profile-entry{
      display:flex; align-items:center; gap:10px; padding:6px 12px; border-radius:999px;
      background:rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 8px 24px rgba(0,0,0,.25);
    }
    .profile-entry img{
      width:32px; height:32px; border-radius:50%;
      box-shadow:0 0 10px var(--gold-soft);
    }
    .profile-entry span{ font-weight:700; letter-spacing:.2px }

    /* Timer / CTA */
    .round-timer{
      position:absolute; left:50%; bottom:156px; transform:translateX(-50%);
      padding:14px 28px; border-radius:999px; font-weight:800; letter-spacing:.3px;
      background:linear-gradient(180deg, rgba(255,215,0,.14), rgba(255,215,0,.06));
      box-shadow:0 0 22px rgba(255,215,0,.25), inset 0 0 0 1px rgba(255,255,255,.08);
      text-shadow:0 0 14px rgba(255,215,0,.18);
      z-index:25; font-family:Orbitron, sans-serif;
    }
    .round-timer.animate{
      animation: pulse 1.8s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform:translateX(-50%) scale(1); box-shadow:0 0 22px rgba(255,215,0,.25) }
      50%{ transform:translateX(-50%) scale(1.05); box-shadow:0 0 30px rgba(255,215,0,.45) }
    }

    .cta{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      display:none; z-index:26; pointer-events:auto;
    }
    .btn{
      padding:14px 28px; border-radius:14px; cursor:pointer; font-weight:800; letter-spacing:.2px;
      background:linear-gradient(180deg, #ffe88a, #ffcc3b);
      color:#000; box-shadow:0 12px 36px rgba(255,215,0,.35);
      transition:transform .16s ease, filter .16s ease;
      font-family:Orbitron, sans-serif;
    }
    .btn:hover{ transform:translateY(-2px); filter:brightness(1.05) }

    /* Floating glass dock (raised) */
    .dock{
      position:absolute; left:50%; bottom:64px; transform:translateX(-50%); /* raised */
      display:flex; gap:10px; z-index:26; pointer-events:auto;
      padding:10px; border-radius:18px;
      background:rgba(255,255,255,.06);
      backdrop-filter: blur(10px) saturate(140%);
      box-shadow: 0 12px 36px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
    }
    .dock-btn{
      width:42px; height:42px; border-radius:12px; display:grid; place-items:center; cursor:pointer;
      color:#fff; font-size:18px;
      background:rgba(255,255,255,.08);
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.06), 0 6px 16px rgba(0,0,0,.25);
      transition: transform .14s ease, background .14s ease;
    }
    .dock-btn:hover{ transform:translateY(-2px); background:rgba(255,255,255,.12) }
    .dock-btn.primary{
      background:linear-gradient(180deg, #ffe88a, #ffcc3b); color:#000;
      box-shadow:0 10px 28px rgba(255,215,0,.35);
    }

    /* Instrumental modal */
    .modal{
      position:absolute; inset:0; display:none; place-items:center; z-index:30; pointer-events:auto;
      background: radial-gradient(1000px 700px at 50% 40%, rgba(255,215,0,.12), rgba(0,0,0,.92));
      backdrop-filter: blur(4px);
    }
    .dialog{
      width:min(92vw,520px); padding:16px; border-radius:16px;
      background:var(--glass);
      box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.10);
      display:grid; gap:12px;
    }
    .dialog h3{ margin:0; font-size:16px; font-weight:800 }
    .field{ display:grid; gap:8px }
    select{
      width:100%; padding:10px 12px; border-radius:12px; outline:0; border:none;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.14);
      background:#0a0a0a; color:var(--ink);
    }
    .dialog-actions{ display:flex; justify-content:flex-end; gap:10px }

    .sr{ position:absolute; width:1px; height:1px; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }

    @media (prefers-reduced-motion: reduce){
      .round-timer.animate{ animation:none }
      .btn:hover, .dock-btn:hover{ transform:none }
    }
  </style>
</head>
<body>
  <!-- 3D animated background -->
  <canvas id="bg3d"></canvas>

  <div class="stream-container" role="application" aria-label="Live Battle Split">
    <!-- Streams -->
    <video class="video-stream" id="localVideo" autoplay muted playsinline></video>
    <video class="video-stream" id="opponentVideo" autoplay muted loop src="user2.mp4" playsinline></video>

    <!-- Top HUD -->
    <div class="top-bar">
      <span class="hud-chip hud-live">LIVE</span>
      <span class="hud-chip">üëÅ‚Äçüó® 1.3k</span>
    </div>

    <!-- Opponent chip -->
    <div class="profile-labels" id="profileLabels">
      <div class="profile-entry">
        <img src="user2.jpg" id="opponentImage" alt="Opponent avatar" />
        <span id="opponentUsername">@Opponent</span>
      </div>
    </div>

    <!-- Timer + CTA -->
    <div class="round-timer" id="roundTimer">Select your instrumental to begin‚Ä¶</div>
    <div class="cta"><button id="startBattleBtn" class="btn">üî• Start Battle</button></div>

    <!-- Floating glass dock (icon-only, raised) -->
    <nav class="dock" aria-label="Primary">
      <button class="dock-btn" data-link="home.html" title="Home">üè†</button>
      <button class="dock-btn" data-link="leaderboard.html" title="Leaderboard">üèÜ</button>
      <button class="dock-btn primary" data-link="battle.html" title="Battle">üéÆ</button>
      <button class="dock-btn" data-link="discover.html" title="Discover">üîç</button>
      <button class="dock-btn" data-link="profile.html" title="Profile">üë§</button>
    </nav>

    <!-- Instrumental modal -->
    <div class="modal" id="instModal" aria-modal="true" role="dialog" aria-labelledby="instTitle">
      <div class="dialog">
        <h3 id="instTitle">Select Instrumental</h3>
        <div class="field">
          <label for="instrumentalSelect" class="sr">Instrumental</label>
          <select id="instrumentalSelect">
            <option disabled selected value="">Choose a beat</option>
            <option value="beat1.mp3">üî• Classic Trap</option>
            <option value="beat2.mp3">üí• Boom Bap</option>
            <option value="beat3.mp3">üåä Chill Vibes</option>
            <option value="beat4.mp3">‚ö° Fast Flow</option>
          </select>
        </div>
        <div class="dialog-actions">
          <button class="btn" id="confirmInst">Confirm</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Audio -->
  <audio id="roundEndSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_38ca955dae.mp3?filename=click-124467.mp3"></audio>
  <audio id="battleTrack" hidden></audio>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // -------- Helpers --------
    const qs = (sel, el=document)=>el.querySelector(sel);
    const qsa = (sel, el=document)=>[...el.querySelectorAll(sel)];

    // -------- Elements --------
    const localVideo   = qs('#localVideo');
    const opponentVideo= qs('#opponentVideo');
    const opponentImage= qs('#opponentImage');
    const opponentUser = qs('#opponentUsername');

    const instModal    = qs('#instModal');
    const selectInst   = qs('#instrumentalSelect');
    const confirmInst  = qs('#confirmInst');
    const startBtnWrap = qs('.cta');
    const startBtn     = qs('#startBattleBtn');
    const timerEl      = qs('#roundTimer');

    const endSound     = qs('#roundEndSound');
    const battleTrack  = qs('#battleTrack');

    // -------- Data --------
    const opponents = [
      { video: "user2.mp4", image: "user2.jpg", username: "@OpponentA" },
      { video: "user3.mp4", image: "user3.jpg", username: "@ChallengerX" },
      { video: "user4.mp4", image: "user4.jpg", username: "@MCNeo" }
    ];

    // -------- Camera --------
    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: true
        });
        localVideo.srcObject = stream;
      }catch(err){
        console.warn('Camera error:', err);
        alert('Please allow camera & mic access.');
      }
    }

    // -------- Dock navigation --------
    qsa('.dock-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{ const link = btn.dataset.link; if(link) location.href = link; });
    });

    // -------- Instrumental modal --------
    function showInstModal(v=true){ instModal.style.display = v ? 'grid' : 'none'; }
    confirmInst.addEventListener('click', ()=>{
      const src = selectInst.value;
      if(!src){ alert('Pick a beat first.'); return; }
      battleTrack.src = src;
      battleTrack.load();
      showInstModal(false);
      startBtnWrap.style.display='block';
      timerEl.textContent = 'Press Start Battle to begin';
    });

    // -------- Battle loop (single interval) --------
    let state = { round:1, part:0, time:33, ticking:null };

    function setTimerText(){
      timerEl.textContent = `Round ${state.round} of 3 | ${state.part===0 ? '@You' : '@Opponent'} | ${state.time}s`;
    }
    function startTick(){
      stopTick();
      state.ticking = setInterval(()=>{
        setTimerText();
        state.time--;
        if(state.time < 0){
          endSound.play().catch(()=>{});
          stopTick();

          if(state.part === 0){
            state.part = 1; state.time = 33;
            transition('Switching to Opponent...');
          }else{
            if(state.round < 3){
              state.round++; state.part = 0; state.time = 33;
              transition('Switching to Next Round...');
            }else{
              timerEl.textContent = 'üî• Battle Over üî•';
              timerEl.classList.add('animate');
              setTimeout(loadRandomOpponent, 2200);
            }
          }
        }
      }, 1000);
    }
    function stopTick(){ if(state.ticking){ clearInterval(state.ticking); state.ticking = null; } }
    function transition(msg){
      timerEl.textContent = msg;
      timerEl.classList.add('animate');
      setTimeout(()=>{ timerEl.classList.remove('animate'); startTick(); }, 800);
    }

    // -------- Opponents --------
    function loadRandomOpponent(){
      const next = opponents[Math.floor(Math.random()*opponents.length)];
      opponentVideo.src = next.video;
      opponentImage.src = next.image;
      opponentUser.textContent = next.username;

      state.round = 1; state.part = 0; state.time = 33;
      startBtnWrap.style.display='block';
      timerEl.textContent = 'üî• New Opponent Ready ‚Äî Press Start üî•';
    }

    // -------- CTA --------
    startBtn.addEventListener('click', async ()=>{
      startBtnWrap.style.display='none';
      try{ await battleTrack.play(); }catch(e){}
      timerEl.classList.add('animate');
      startTick();
      BG.stop(); // stop explosions when battle starts
    });

    // -------- Init --------
    window.addEventListener('load', ()=>{
      startCamera();
      showInstModal(true);
      battleTrack.preload = 'auto';
      BG.start(); // kick off background
    });

    // ESC to close modal
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && instModal.style.display === 'grid'){ showInstModal(false); }
    });

    // ========= 3D Explosion Background (gold/ember), stoppable =========
    const BG = (function(){
      const reduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      const DPR_LIMIT = 1.75;
      const MAX_EXPLOSIONS = reduced ? 4 : 9;
      const BLAST_INTERVAL = reduced ? 1800 : 1300;
      const START_WITH_BLAST = true;

      const canvas = document.getElementById('bg3d');
      let renderer, scene, camera;
      let width = window.innerWidth, height = window.innerHeight;
      let running = false, raf = 0;
      let explosions = [];
      let prev = 0, lastBlast = 0;

      // ambient
      let ambient, particleTex;

      function safeInit(){
        try{
          const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
          if(!gl) throw new Error('WebGL not supported');
        }catch(e){
          console.warn('WebGL unavailable, showing gradient fallback.');
          return false;
        }
        return true;
      }

      function init(){
        renderer = new THREE.WebGLRenderer({ canvas, antialias:false, alpha:true, powerPreference:'high-performance' });
        renderer.setClearColor(0x000000, 0);
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, reduced ? 0.0008 : 0.0012);

        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, DPR_LIMIT));
        renderer.setSize(width, height, false);

        camera = new THREE.PerspectiveCamera(55, width/height, 0.1, 3000);
        camera.position.set(0, 0, 140);

        const hemi = new THREE.HemisphereLight(0xaaaaaa, 0x0a0a0a, 0.8);
        const dir  = new THREE.DirectionalLight(0xffe7a4, 0.7);
        dir.position.set(60, 80, 120);
        scene.add(hemi, dir);

        // sprite texture (soft disc)
        particleTex = (function(){
          const size = 128;
          const c = document.createElement('canvas'); c.width=c.height=size;
          const g = c.getContext('2d');
          const grad = g.createRadialGradient(size/2,size/2,0, size/2,size/2,size/2);
          grad.addColorStop(0,'rgba(255,255,255,0.95)');
          grad.addColorStop(0.35,'rgba(255,255,255,0.35)');
          grad.addColorStop(1,'rgba(255,255,255,0.0)');
          g.fillStyle = grad; g.fillRect(0,0,size,size);
          const tex = new THREE.CanvasTexture(c);
          tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.anisotropy = 1;
          return tex;
        })();

        // ambient ember field
        ambient = (function(){
          const COUNT = reduced ? 300 : 600;
          const g = new THREE.BufferGeometry();
          const positions = new Float32Array(COUNT*3);
          const colors    = new Float32Array(COUNT*3);
          for(let i=0;i<COUNT;i++){
            positions[i*3+0] = rand(-220,220);
            positions[i*3+1] = rand(-140,140);
            positions[i*3+2] = rand(-180,60);
            const t = Math.random()*0.5+0.35;
            colors[i*3+0] = t; colors[i*3+1] = t*0.9; colors[i*3+2] = t*0.85;
          }
          g.setAttribute('position', new THREE.BufferAttribute(positions,3));
          g.setAttribute('color', new THREE.BufferAttribute(colors,3));
          const m = new THREE.PointsMaterial({
            size: reduced ? 2.0 : 3.0, map:particleTex, transparent:true, depthWrite:false,
            vertexColors:true, blending:THREE.AdditiveBlending
          });
          const p = new THREE.Points(g,m);
          p.frustumCulled = false;
          p.userData = { t:0 };
          return p;
        })();
        scene.add(ambient);

        window.addEventListener('resize', resize, { passive:true });
      }

      const baseMat = ()=> new THREE.PointsMaterial({
        size: (reduced? 16 : 20),
        map: particleTex, transparent:true, depthWrite:false,
        blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true
      });
      const ringMatStrong = ()=> new THREE.MeshBasicMaterial({ color:0xffd700, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, side:THREE.DoubleSide });
      const ringMatSoft   = ()=> new THREE.MeshBasicMaterial({ color:0xffe18a, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, side:THREE.DoubleSide });

      const pool = [];
      function getPoints(count){
        for(let i=pool.length-1;i>=0;i--){
          const p = pool[i];
          const existing = p.geometry.getAttribute('position').count;
          if(existing >= count){ pool.splice(i,1); p.visible=true; return p; }
        }
        const g = new THREE.BufferGeometry();
        const positions = new Float32Array(count*3);
        const colors    = new Float32Array(count*3);
        const sizes     = new Float32Array(count);
        g.setAttribute('position', new THREE.BufferAttribute(positions,3));
        g.setAttribute('color',    new THREE.BufferAttribute(colors,3));
        g.setAttribute('size',     new THREE.BufferAttribute(sizes,1));
        const m = baseMat();
        const points = new THREE.Points(g, m);
        points.frustumCulled = false;
        return points;
      }
      function releasePoints(points){ points.visible=false; pool.push(points); }

      class Explosion {
        constructor(){
          const x = rand(-0.42*width, 0.42*width) / 6;
          const y = rand(-0.45*height, 0.45*height) / 6;
          const z = rand(-60, 20);
          this.center = new THREE.Vector3(x,y,z);

          this.life = reduced ? 1.5 : 1.9;
          this.t = 0;

          this.count = (Math.random()*50 + (reduced? 75 : 120)) | 0;
          this.points = getPoints(this.count);
          this.points.position.copy(this.center);

          const g = this.points.geometry;
          const pos = g.getAttribute('position').array;
          const col = g.getAttribute('color').array;
          const siz = g.getAttribute('size').array;

          this.vel = new Float32Array(this.count*3);
          for(let i=0;i<this.count;i++){
            const dirv = new THREE.Vector3().randomDirection();
            const speed = rand(12, 34);
            this.vel[i*3+0] = dirv.x*speed;
            this.vel[i*3+1] = dirv.y*speed;
            this.vel[i*3+2] = dirv.z*speed;

            pos[i*3+0] = dirv.x*1.6;
            pos[i*3+1] = dirv.y*1.6;
            pos[i*3+2] = dirv.z*1.6;

            col[i*3+0] = 1.0; col[i*3+1] = 1.0; col[i*3+2] = 1.0;
            siz[i] = rand(8, 14);
          }
          g.getAttribute('position').needsUpdate = true;
          g.getAttribute('color').needsUpdate    = true;
          g.getAttribute('size').needsUpdate     = true;

          scene.add(this.points);

          const ringGeo = new THREE.RingGeometry(5, 6.6, 64);
          this.ring1 = new THREE.Mesh(ringGeo, ringMatStrong().clone());
          this.ring2 = new THREE.Mesh(ringGeo, ringMatSoft().clone());
          this.ring1.position.copy(this.center);
          this.ring2.position.copy(this.center);
          this.r1 = 5; this.r2 = 5;
          scene.add(this.ring1, this.ring2);

          this.shake = 0.45;
        }

        update(dt){
          this.t += dt;
          const f = this.t/this.life;

          const g = this.points.geometry;
          const pos = g.getAttribute('position').array;
          const col = g.getAttribute('color').array;
          const siz = g.getAttribute('size').array;

          const drag = 1.0 - Math.min(0.05*dt*60, 0.05);

          for(let i=0;i<this.count;i++){
            const ix = i*3;
            pos[ix+0] += this.vel[ix+0]*dt;
            pos[ix+1] += this.vel[ix+1]*dt;
            pos[ix+2] += this.vel[ix+2]*dt;
            this.vel[ix+0] *= drag;
            this.vel[ix+1] *= drag;
            this.vel[ix+2] *= drag;

            const toGold = smoothstep(0.25, 0.55, f);
            col[ix+0] = lerp(1.0, 1.00, toGold);
            col[ix+1] = lerp(1.0, 0.72, toGold);
            col[ix+2] = lerp(1.0, 0.28, toGold);

            siz[i] *= (1 - dt*0.1);
            siz[i] = Math.max(7, siz[i]);
          }
          g.getAttribute('position').needsUpdate = true;
          g.getAttribute('color').needsUpdate    = true;
          g.getAttribute('size').needsUpdate     = true;

          this.r1 += 100*dt;
          this.r2 += 125*dt;
          this.ring1.scale.setScalar(this.r1/5);
          this.ring2.scale.setScalar(this.r2/5);
          this.ring1.material.opacity = Math.max(0, 0.95 - f*1.25);
          this.ring2.material.opacity = Math.max(0, 0.65 - f*1.3);
          this.ring1.lookAt(camera.position);
          this.ring2.lookAt(camera.position);

          if(this.shake>0){
            const s = this.shake*(1-f);
            camera.position.x += (Math.random()-0.5)*s;
            camera.position.y += (Math.random()-0.5)*s;
          }

          return this.t < this.life;
        }

        dispose(){
          scene.remove(this.points); releasePoints(this.points);
          scene.remove(this.ring1); scene.remove(this.ring2);
        }
      }

      function loop(now){
        if(!running) return;
        const dt = Math.min(0.05, (now - prev)/1000); prev = now;

        // ambient drift
        if(ambient){
          ambient.userData.t = (ambient.userData.t || 0) + dt*0.2;
          ambient.position.y = Math.sin(ambient.userData.t)*2;
          ambient.rotation.z += dt*0.02;
        }

        // schedule explosions
        if(now - lastBlast > BLAST_INTERVAL){
          if(explosions.length > MAX_EXPLOSIONS){
            const old = explosions.shift(); old.dispose();
          }
          explosions.push(new Explosion());
          lastBlast = now;
        }

        // update explosions
        for(let i=explosions.length-1;i>=0;i--){
          if(!explosions[i].update(dt)){
            explosions[i].dispose();
            explosions.splice(i,1);
          }
        }

        camera.lookAt(0,0,0);
        renderer.render(scene, camera);
        raf = requestAnimationFrame(loop);
      }

      function start(){
        if(running) return;
        if(!safeInit()) return;
        width = window.innerWidth; height = window.innerHeight;
        init();
        explosions = [];
        prev = performance.now(); lastBlast = prev;
        if(START_WITH_BLAST) explosions.push(new Explosion());
        running = true;
        raf = requestAnimationFrame(loop);
      }

      function stop(){
        if(!running) return;
        running = false;
        cancelAnimationFrame(raf);
        // Freeze current scene; dispose active animations
        for(const e of explosions){ e.dispose(); }
        explosions = [];
        // leave ambient + last frame rendered; nothing else to do
      }

      function resize(){
        width = window.innerWidth; height = window.innerHeight;
        if(!renderer || !camera) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, DPR_LIMIT));
        renderer.setSize(width, height, false);
        camera.aspect = width/height;
        camera.updateProjectionMatrix();
      }

      function rand(a,b){ return a + Math.random()*(b-a); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function smoothstep(a,b,x){ const t = Math.max(0, Math.min(1, (x-a)/(b-a))); return t*t*(3 - 2*t); }

      return { start, stop };
    })();
  </script>
</body>
</html>
