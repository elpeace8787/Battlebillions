<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BattleBillions ‚Äî Dual Live Battle</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;800&family=Orbitron:wght@600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --ink:#f5f5f5;
      --muted:#b7b7b7;
      --gold:#ffd700;
      --gold-1:#ffe88a;
      --gold-2:#ffcc3b;
      --glass: rgba(20,20,24,.45);
      --grey-glass: rgba(255,255,255,.08);
      --grey-glass-strong: rgba(255,255,255,.12);
    }

    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      color:var(--ink);
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      /* Static deep background (no animation) */
      background:
        radial-gradient(1200px 800px at 30% 20%, #101012 0%, #000 70%),
        linear-gradient(180deg, #050507, #000);
      overflow:hidden;
    }

    /* Foreground container */
    .stream-container{
      position:relative; z-index:1;
      display:flex; height:100vh; width:100vw; gap:0;
    }
    .video-stream{
      flex:1; width:50%; height:100%; object-fit:cover; background:#000;
      filter: brightness(.92) contrast(1.12) saturate(1.12);
    }

    /* Top HUD (minimal) */
    .top-bar{
      position:absolute; left:0; right:0; top:0; z-index:20; pointer-events:none;
      display:flex; justify-content:space-between; align-items:center; padding:10px 14px;
      background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0));
      backdrop-filter: blur(8px) saturate(120%);
    }
    .hud-chip{
      pointer-events:auto;
      display:inline-flex; align-items:center; gap:8px; padding:6px 12px; border-radius:999px;
      background:rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 8px 24px rgba(0,0,0,.25);
      font-size:12px; letter-spacing:.2px;
    }
    .hud-live{
      color:#000; background:linear-gradient(180deg,var(--gold-1),var(--gold-2));
      box-shadow: 0 10px 28px rgba(255,215,0,.35);
      font-weight:800; font-family:Orbitron, sans-serif;
    }

    /* Opponent chip */
    .profile-labels{
      position:absolute; top:58px; right:20px; display:flex; gap:10px; z-index:22;
    }
    .profile-entry{
      display:flex; align-items:center; gap:10px; padding:6px 12px; border-radius:999px;
      background:rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), 0 8px 24px rgba(0,0,0,.25);
    }
    .profile-entry img{
      width:32px; height:32px; border-radius:50%;
      box-shadow:0 0 10px rgba(255,215,0,.18);
    }
    .profile-entry span{ font-weight:700; letter-spacing:.2px }

    /* Timer / CTA */
    .round-timer{
      position:absolute; left:50%; bottom:156px; transform:translateX(-50%);
      padding:14px 28px; border-radius:999px; font-weight:800; letter-spacing:.3px;
      background:linear-gradient(180deg, rgba(255,215,0,.14), rgba(255,215,0,.06));
      box-shadow:0 0 22px rgba(255,215,0,.25), inset 0 0 0 1px rgba(255,255,255,.08);
      text-shadow:0 0 14px rgba(255,215,0,.18);
      z-index:25; font-family:Orbitron, sans-serif;
    }
    .round-timer.animate{
      animation: pulse 1.8s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform:translateX(-50%) scale(1); box-shadow:0 0 22px rgba(255,215,0,.25) }
      50%{ transform:translateX(-50%) scale(1.05); box-shadow:0 0 30px rgba(255,215,0,.45) }
    }

    .cta{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      display:none; z-index:26; pointer-events:auto;
    }
    .btn{
      padding:14px 28px; border-radius:14px; cursor:pointer; font-weight:800; letter-spacing:.2px;
      background:linear-gradient(180deg, var(--gold-1), var(--gold-2));
      color:#000; box-shadow:0 12px 36px rgba(255,215,0,.35);
      transition:transform .16s ease, filter .16s ease;
      font-family:Orbitron, sans-serif;
    }
    .btn:hover{ transform:translateY(-2px); filter:brightness(1.05) }

    /* Floating glass dock (icon-only) ‚Äì clear glass gold/grey */
    .dock{
      position:absolute; left:50%; bottom:64px; transform:translateX(-50%);
      display:flex; gap:10px; z-index:26; pointer-events:auto;
      padding:10px; border-radius:18px;
      background:rgba(255,255,255,.06);
      backdrop-filter: blur(10px) saturate(140%);
      box-shadow: 0 12px 36px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
    }
    .dock-btn{
      width:44px; height:44px; border-radius:12px; display:grid; place-items:center; cursor:pointer;
      font-size:19px;
      /* smoked-glass grey button */
      color:#d6d6d6;
      background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.06),
        0 6px 16px rgba(0,0,0,.25);
      transition: transform .14s ease, background .14s ease, color .14s ease;
    }
    .dock-btn:hover{
      transform:translateY(-2px);
      background:linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.08));
      color:#ffffff;
    }
    .dock-btn.primary{
      /* clear glass gold button */
      color:#000;
      background:linear-gradient(180deg, var(--gold-1), var(--gold-2));
      box-shadow:0 10px 28px rgba(255,215,0,.35), inset 0 0 0 1px rgba(255,255,255,.28);
    }

    /* Instrumental modal */
    .modal{
      position:absolute; inset:0; display:none; place-items:center; z-index:30; pointer-events:auto;
      background: radial-gradient(1000px 700px at 50% 40%, rgba(255,215,0,.12), rgba(0,0,0,.92));
      backdrop-filter: blur(4px);
    }
    .dialog{
      width:min(92vw,520px); padding:16px; border-radius:16px;
      background:var(--glass);
      box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.10);
      display:grid; gap:12px;
    }
    .dialog h3{ margin:0; font-size:16px; font-weight:800 }
    .field{ display:grid; gap:8px }
    select{
      width:100%; padding:10px 12px; border-radius:12px; outline:0; border:none;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.14);
      background:#0a0a0a; color:var(--ink);
    }
    .dialog-actions{ display:flex; justify-content:flex-end; gap:10px }

    .sr{ position:absolute; width:1px; height:1px; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }

    /* Single-use FX canvas (hidden by default) */
    #fxCanvas{
      position:fixed; inset:0; width:100%; height:100%;
      display:none; pointer-events:none; z-index:0;
    }

    @media (prefers-reduced-motion: reduce){
      .round-timer.animate{ animation:none }
      .btn:hover, .dock-btn:hover{ transform:none }
    }
  </style>
</head>
<body>
  <!-- Single-use explosion canvas (hidden until Start) -->
  <canvas id="fxCanvas"></canvas>

  <div class="stream-container" role="application" aria-label="Live Battle Split">
    <!-- Streams -->
    <video class="video-stream" id="localVideo" autoplay muted playsinline></video>
    <video class="video-stream" id="opponentVideo" autoplay muted loop src="user2.mp4" playsinline></video>

    <!-- Top HUD -->
    <div class="top-bar">
      <span class="hud-chip hud-live">LIVE</span>
      <span class="hud-chip">üëÅ‚Äçüó® 1.3k</span>
    </div>

    <!-- Opponent chip -->
    <div class="profile-labels" id="profileLabels">
      <div class="profile-entry">
        <img src="user2.jpg" id="opponentImage" alt="Opponent avatar" />
        <span id="opponentUsername">@Opponent</span>
      </div>
    </div>

    <!-- Timer + CTA -->
    <div class="round-timer" id="roundTimer">Select your instrumental to begin‚Ä¶</div>
    <div class="cta"><button id="startBattleBtn" class="btn">üî• Start Battle</button></div>

    <!-- Floating glass dock (icon-only, clear gold & grey) -->
    <nav class="dock" aria-label="Primary">
      <button class="dock-btn" data-link="home.html" title="Home">üè†</button>
      <button class="dock-btn" data-link="leaderboard.html" title="Leaderboard">üèÜ</button>
      <button class="dock-btn primary" data-link="battle.html" title="Battle">üéÆ</button>
      <button class="dock-btn" data-link="discover.html" title="Discover">üîç</button>
      <button class="dock-btn" data-link="profile.html" title="Profile">üë§</button>
    </nav>

    <!-- Instrumental modal -->
    <div class="modal" id="instModal" aria-modal="true" role="dialog" aria-labelledby="instTitle">
      <div class="dialog">
        <h3 id="instTitle">Select Instrumental</h3>
        <div class="field">
          <label for="instrumentalSelect" class="sr">Instrumental</label>
          <select id="instrumentalSelect">
            <option disabled selected value="">Choose a beat</option>
            <option value="beat1.mp3">üî• Classic Trap</option>
            <option value="beat2.mp3">üí• Boom Bap</option>
            <option value="beat3.mp3">üåä Chill Vibes</option>
            <option value="beat4.mp3">‚ö° Fast Flow</option>
          </select>
        </div>
        <div class="dialog-actions">
          <button class="btn" id="confirmInst">Confirm</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Audio -->
  <audio id="roundEndSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_38ca955dae.mp3?filename=click-124467.mp3"></audio>
  <audio id="battleTrack" hidden></audio>

  <!-- Three.js for one-shot FX -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // -------- Helpers --------
    const qs = (sel, el=document)=>el.querySelector(sel);
    const qsa = (sel, el=document)=>[...el.querySelectorAll(sel)];

    // -------- Elements --------
    const localVideo   = qs('#localVideo');
    const opponentVideo= qs('#opponentVideo');
    const opponentImage= qs('#opponentImage');
    const opponentUser = qs('#opponentUsername');

    const instModal    = qs('#instModal');
    const selectInst   = qs('#instrumentalSelect');
    const confirmInst  = qs('#confirmInst');
    const startBtnWrap = qs('.cta');
    const startBtn     = qs('#startBattleBtn');
    const timerEl      = qs('#roundTimer');

    const endSound     = qs('#roundEndSound');
    const battleTrack  = qs('#battleTrack');

    // -------- Data --------
    const opponents = [
      { video: "user2.mp4", image: "user2.jpg", username: "@OpponentA" },
      { video: "user3.mp4", image: "user3.jpg", username: "@ChallengerX" },
      { video: "user4.mp4", image: "user4.jpg", username: "@MCNeo" }
    ];

    // -------- Camera --------
    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: true
        });
        localVideo.srcObject = stream;
      }catch(err){
        console.warn('Camera error:', err);
        alert('Please allow camera & mic access.');
      }
    }

    // -------- Dock navigation --------
    qsa('.dock-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{ const link = btn.dataset.link; if(link) location.href = link; });
    });

    // -------- Instrumental modal --------
    function showInstModal(v=true){ instModal.style.display = v ? 'grid' : 'none'; }
    confirmInst.addEventListener('click', ()=>{
      const src = selectInst.value;
      if(!src){ alert('Pick a beat first.'); return; }
      battleTrack.src = src;
      battleTrack.load();
      showInstModal(false);
      startBtnWrap.style.display='block';
      timerEl.textContent = 'Press Start Battle to begin';
    });

    // -------- Battle loop (single interval) --------
    let state = { round:1, part:0, time:33, ticking:null };

    function setTimerText(){
      timerEl.textContent = `Round ${state.round} of 3 | ${state.part===0 ? '@You' : '@Opponent'} | ${state.time}s`;
    }
    function startTick(){
      stopTick();
      state.ticking = setInterval(()=>{
        setTimerText();
        state.time--;
        if(state.time < 0){
          endSound.play().catch(()=>{});
          stopTick();

          if(state.part === 0){
            state.part = 1; state.time = 33;
            transition('Switching to Opponent...');
          }else{
            if(state.round < 3){
              state.round++; state.part = 0; state.time = 33;
              transition('Switching to Next Round...');
            }else{
              timerEl.textContent = 'üî• Battle Over üî•';
              timerEl.classList.add('animate');
              setTimeout(loadRandomOpponent, 2200);
            }
          }
        }
      }, 1000);
    }
    function stopTick(){ if(state.ticking){ clearInterval(state.ticking); state.ticking = null; } }
    function transition(msg){
      timerEl.textContent = msg;
      timerEl.classList.add('animate');
      setTimeout(()=>{ timerEl.classList.remove('animate'); startTick(); }, 800);
    }

    // -------- Opponents --------
    function loadRandomOpponent(){
      const next = opponents[Math.floor(Math.random()*opponents.length)];
      opponentVideo.src = next.video;
      opponentImage.src = next.image;
      opponentUser.textContent = next.username;

      state.round = 1; state.part = 0; state.time = 33;
      startBtnWrap.style.display='block';
      timerEl.textContent = 'üî• New Opponent Ready ‚Äî Press Start üî•';
    }

    // -------- CTA --------
    startBtn.addEventListener('click', async ()=>{
      startBtnWrap.style.display='none';
      try{ await battleTrack.play(); }catch(e){}
      timerEl.classList.add('animate');
      startTick();
      FX.oneExplosion(); // play a single explosion once battle starts
    });

    // -------- Init --------
    window.addEventListener('load', ()=>{
      startCamera();
      showInstModal(true);
      battleTrack.preload = 'auto';
    });

    // ESC to close modal
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && instModal.style.display === 'grid'){ showInstModal(false); }
    });

    // ========= Single-shot Explosion FX (centered) =========
    const FX = (function(){
      let renderer, scene, camera, ambient, particleTex, raf=0, running=false;
      const canvas = document.getElementById('fxCanvas');

      function init(){
        if(running) return;
        // WebGL support check
        try{
          const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
          if(!gl) throw new Error('WebGL not supported');
        }catch(e){
          console.warn('WebGL unavailable; skipping FX.');
          return false;
        }

        // Size & show
        canvas.style.display = 'block';
        const DPR_LIMIT=1.75;
        const w = window.innerWidth, h = window.innerHeight;

        renderer = new THREE.WebGLRenderer({ canvas, antialias:false, alpha:true, powerPreference:'high-performance' });
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, DPR_LIMIT));
        renderer.setSize(w, h, false);

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0012);

        camera = new THREE.PerspectiveCamera(55, w/h, 0.1, 3000);
        camera.position.set(0, 0, 140);

        const hemi = new THREE.HemisphereLight(0xaaaaaa, 0x0a0a0a, 0.8);
        const dir  = new THREE.DirectionalLight(0xffe7a4, 0.7);
        dir.position.set(60, 80, 120);
        scene.add(hemi, dir);

        // soft disc texture
        particleTex = (()=>{ const s=128,c=document.createElement('canvas'); c.width=c.height=s;
          const g=c.getContext('2d'); const grd=g.createRadialGradient(s/2,s/2,0,s/2,s/2,s/2);
          grd.addColorStop(0,'rgba(255,255,255,0.95)'); grd.addColorStop(0.35,'rgba(255,255,255,0.35)'); grd.addColorStop(1,'rgba(255,255,255,0)');
          g.fillStyle=grd; g.fillRect(0,0,s,s);
          const tex=new THREE.CanvasTexture(c); tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; return tex; })();

        // ambient embers (subtle)
        ambient = (()=>{ const COUNT=500, g=new THREE.BufferGeometry();
          const positions=new Float32Array(COUNT*3), colors=new Float32Array(COUNT*3);
          for(let i=0;i<COUNT;i++){ positions[i*3]=rand(-220,220); positions[i*3+1]=rand(-140,140); positions[i*3+2]=rand(-180,60);
            const t=Math.random()*0.5+0.35; colors[i*3]=t; colors[i*3+1]=t*0.9; colors[i*3+2]=t*0.85; }
          g.setAttribute('position',new THREE.BufferAttribute(positions,3)); g.setAttribute('color',new THREE.BufferAttribute(colors,3));
          const m=new THREE.PointsMaterial({ size:3.0, map:particleTex, transparent:true, depthWrite:false, vertexColors:true, blending:THREE.AdditiveBlending });
          const p=new THREE.Points(g,m); p.frustumCulled=false; p.userData={t:0}; return p; })();
        scene.add(ambient);

        return true;
      }

      class Explosion {
        constructor(center=new THREE.Vector3(0,0,0)){
          this.center=center.clone(); this.life=1.9; this.t=0;
          this.count=(Math.random()*60 + 140) | 0;
          const g=new THREE.BufferGeometry();
          const positions=new Float32Array(this.count*3);
          const colors=new Float32Array(this.count*3);
          const sizes=new Float32Array(this.count);
          this.vel=new Float32Array(this.count*3);
          for(let i=0;i<this.count;i++){
            const dirv=new THREE.Vector3().randomDirection(); const speed=rand(14,42);
            this.vel[i*3]=dirv.x*speed; this.vel[i*3+1]=dirv.y*speed; this.vel[i*3+2]=dirv.z*speed;
            positions[i*3]=dirv.x*2; positions[i*3+1]=dirv.y*2; positions[i*3+2]=dirv.z*2;
            colors[i*3]=1.0; colors[i*3+1]=1.0; colors[i*3+2]=1.0; sizes[i]=rand(10,18);
          }
          g.setAttribute('position', new THREE.BufferAttribute(positions,3));
          g.setAttribute('color',    new THREE.BufferAttribute(colors,3));
          g.setAttribute('size',     new THREE.BufferAttribute(sizes,1));
          const mat=new THREE.PointsMaterial({ size:20, map:particleTex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
          this.points=new THREE.Points(g,mat); this.points.position.copy(this.center); this.points.frustumCulled=false; scene.add(this.points);

          const ringGeo=new THREE.RingGeometry(6,7.6,64);
          this.ring1=new THREE.Mesh(ringGeo,new THREE.MeshBasicMaterial({ color:0xffd700, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, side:THREE.DoubleSide }));
          this.ring2=new THREE.Mesh(ringGeo,new THREE.MeshBasicMaterial({ color:0xffe18a, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, side:THREE.DoubleSide }));
          this.ring1.position.copy(this.center); this.ring2.position.copy(this.center); this.r1=6; this.r2=6;
          scene.add(this.ring1,this.ring2);

          this.shake=0.5;
        }
        update(dt){
          this.t+=dt; const f=this.t/this.life; const drag=1.0-Math.min(0.05*dt*60,0.05);
          const g=this.points.geometry; const pos=g.getAttribute('position').array; const col=g.getAttribute('color').array; const siz=g.getAttribute('size').array;
          for(let i=0;i<this.count;i++){
            const ix=i*3; pos[ix]+=this.vel[ix]*dt; pos[ix+1]+=this.vel[ix+1]*dt; pos[ix+2]+=this.vel[ix+2]*dt;
            this.vel[ix]*=drag; this.vel[ix+1]*=drag; this.vel[ix+2]*=drag;
            const toGold=smoothstep(0.25,0.55,f); col[ix]=lerp(1.0,1.0,toGold); col[ix+1]=lerp(1.0,0.72,toGold); col[ix+2]=lerp(1.0,0.28,toGold);
            siz[i]*=(1-dt*0.1); siz[i]=Math.max(8,siz[i]);
          }
          g.getAttribute('position').needsUpdate=true; g.getAttribute('color').needsUpdate=true; g.getAttribute('size').needsUpdate=true;

          this.r1+=120*dt; this.r2+=150*dt;
          this.ring1.scale.setScalar(this.r1/6); this.ring2.scale.setScalar(this.r2/6);
          this.ring1.material.opacity=Math.max(0,0.95 - f*1.3);
       this.ring2.material.opacity=Math.max(0,0.65 - f*1.4);
          this.ring1.lookAt(camera.position); this.ring2.lookAt(camera.position);

          if(this.shake>0){ const s=this.shake*(1-f); camera.position.x+=(Math.random()-0.5)*s; camera.position.y+=(Math.random()-0.5)*s; }
          return this.t < this.life;
        }
        dispose(){
          scene.remove(this.points); scene.remove(this.ring1); scene.remove(this.ring2);
          this.points.geometry.dispose(); this.ring1.geometry.dispose(); this.ring2.geometry.dispose();
        }
      }

      function oneExplosion(){
        if(!init()) return;
        running=true;
        const center = new THREE.Vector3(0,0,0);
        const boom = new Explosion(center);
        let prev = performance.now();

        function frame(now){
          if(!running) return;
          const dt=Math.min(0.05,(now - prev)/1000); prev=now;

          // subtle ambient drift
          ambient.userData.t = (ambient.userData.t || 0) + dt*0.2;
          ambient.position.y = Math.sin(ambient.userData.t)*2;
          ambient.rotation.z += dt*0.02;

          if(!boom.update(dt)){
            boom.dispose();
            teardown(); // end effect after single explosion
            return;
          }
          camera.lookAt(0,0,0);
          renderer.render(scene,camera);
          raf=requestAnimationFrame(frame);
        }
        raf=requestAnimationFrame(frame);
      }

      function teardown(){
        running=false;
        if(raf) cancelAnimationFrame(raf);
        // Dispose renderer/scene minimally
        renderer && renderer.dispose();
        scene = null; camera = null; renderer = null; ambient = null; particleTex = null;
        canvas.style.display='none'; // hide canvas after effect
      }

      function rand(a,b){ return a + Math.random()*(b-a); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function smoothstep(a,b,x){ const t=Math.max(0,Math.min(1,(x-a)/(b-a))); return t*t*(3-2*t); }

      return { oneExplosion };
    })();
  </script>
</body>
</html>
