<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Arena — Dual Camera Preview & Recording</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet" />
<style>
  :root{
    --vh:100svh;
    --bg:#07080c; --ink:#f6f7fb; --bd:#ffffff24;
    --accent:#4cf0ff; --accent2:#ff2e6f;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  header{
    position:sticky;top:0;z-index:20;display:flex;align-items:center;gap:.6rem;
    padding:.55rem .8rem;background:rgba(10,11,16,.9);backdrop-filter:blur(8px);border-bottom:1px solid var(--bd)
  }
  .spacer{flex:1}
  .btn{border:1px solid var(--bd);background:#151827;color:var(--ink);border-radius:12px;padding:.5rem .8rem;font-weight:800}
  .btn.gold{background:linear-gradient(180deg,#ffe88a,#ffc400);border:none;color:#141414}
  .btn.small{padding:.42rem .6rem;border-radius:10px}
  .tag{font-weight:800;opacity:.85}

  /* Arena surface */
  .arena{height:var(--vh);position:relative;overflow:hidden}
  /* Animated background stack */
  .bgHue{
    position:absolute;inset:-12% -12% 0 -12%;z-index:0;
    background:
      radial-gradient(1200px 520px at 50% -220px, rgba(255,255,255,.06), transparent 60%),
      radial-gradient(1000px 460px at 50% 115%, rgba(76,240,255,.09), transparent 60%),
      linear-gradient(180deg, rgba(0,0,0,.3), rgba(0,0,0,.75));
    animation:hue 30s linear infinite alternate
  }
  @keyframes hue{from{filter:hue-rotate(0deg)}to{filter:hue-rotate(20deg)}}
  canvas#stars{position:absolute;inset:-6% -6% 0 -6%;z-index:0}
  .scan{position:absolute;inset:0;z-index:0;mix-blend-mode:soft-light;opacity:.18;
    background:repeating-linear-gradient(0deg,rgba(255,255,255,.05) 0 1px,transparent 1px 3px)}

  .arcs{position:absolute;left:50%;top:52%;width:82vw;max-width:920px;transform:translateX(-50%);z-index:0;opacity:.65}
  .arcs path{fill:none;stroke:url(#arcGrad);stroke-width:3;stroke-linecap:round;stroke-dasharray:320;stroke-dashoffset:320;animation:draw 7s ease-in-out infinite}
  .arcs path:nth-child(2){animation-delay:.8s;opacity:.8}
  .arcs path:nth-child(3){animation-delay:1.6s;opacity:.55}
  @keyframes draw{50%{stroke-dashoffset:0}100%{stroke-dashoffset:-320}}

  /* Two vertical panels that read like one screen */
  .panes{
    position:absolute;inset:0;display:grid;grid-template-columns:1fr 1fr;gap:0;z-index:1
  }
  .pane{position:relative;overflow:hidden;background:#000}
  .pane video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;
    filter:contrast(1.08) saturate(1.05) brightness(1.02)}
  /* Feather center masks to remove the split */
  .left video{mask-image:linear-gradient(to right, black 0 86%, transparent 100%);-webkit-mask-image:linear-gradient(to right, black 0 86%, transparent 100%)}
  .right video{mask-image:linear-gradient(to left, black 0 86%, transparent 100%);-webkit-mask-image:linear-gradient(to left, black 0 86%, transparent 100%)}
  /* subtle seam glow */
  .panes:after{content:"";position:absolute;left:50%;top:0;bottom:0;width:3px;transform:translateX(-1.5px);
    background:linear-gradient(180deg,transparent,#ffffff1f 20%,#88f0ff33 50%,transparent 80%);filter:blur(.5px);opacity:.7}

  /* Control dock */
  .dock{
    position:absolute;left:0;right:0;bottom:0;z-index:5;
    padding:.6rem .7rem calc(.7rem + env(safe-area-inset-bottom));
    background:linear-gradient(180deg,transparent 0%, rgba(8,8,10,.75) 22%, rgba(8,8,10,.96) 70%);
    border-top:1px solid var(--bd)
  }
  .row{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;justify-content:center}

  /* Recorder preview */
  .recbar{position:sticky;bottom:0;z-index:22;padding:.4rem .6rem;background:rgba(10,11,16,.9);border-top:1px solid var(--bd);display:flex;gap:.5rem;align-items:center}
  video#recPreview{max-width:180px;max-height:120px;border-radius:10px;border:1px solid var(--bd)}
</style>
</head>
<body>
<header>
  <strong class="tag">ARENA</strong>
  <div class="spacer"></div>
  <button class="btn small" id="flip">Flip Cam</button>
  <button class="btn small" id="startCam">Start Camera</button>
  <button class="btn small" id="stopCam">Stop Camera</button>
  <button class="btn gold small" id="startRec">Start Recording</button>
  <button class="btn small" id="stopRec" disabled>Stop & Save</button>
</header>

<section class="arena" id="arena">
  <!-- Animated background -->
  <div class="bgHue"></div>
  <canvas id="stars"></canvas>
  <div class="scan"></div>
  <svg class="arcs" viewBox="0 0 800 300" preserveAspectRatio="none" aria-hidden="true">
    <defs><linearGradient id="arcGrad" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0" stop-color="#4cf0ff"/><stop offset="1" stop-color="#ff2e6f"/></linearGradient></defs>
    <path d="M20 240 Q 400 40 780 240"/>
    <path d="M80 260 Q 400 70 720 260"/>
    <path d="M160 280 Q 400 110 640 280"/>
  </svg>

  <!-- Two “one-screen” panels (same camera on both sides) -->
  <div class="panes">
    <article class="pane left"><video id="vidA" playsinline muted></video></article>
    <article class="pane right"><video id="vidB" playsinline muted></video></article>
  </div>

  <!-- Controls dock -->
  <div class="dock">
    <div class="row">
      <span class="tag">Camera appears on both panels • Recording saves the full arena</span>
    </div>
  </div>
</section>

<!-- Recorder preview row -->
<div class="recbar">
  <video id="recPreview" playsinline muted></video>
  <a id="downloadLink" class="btn small" style="display:none">Download</a>
  <span id="recStatus" class="tag">Idle</span>
</div>

<script>
  const $ = s => document.querySelector(s);

  /* True mobile viewport */
  function setVH(){ const vv=window.visualViewport; document.documentElement.style.setProperty('--vh', Math.round(vv?.height||innerHeight)+'px'); }
  ['load','resize','orientationchange','scroll'].forEach(e=>addEventListener(e,setVH,{passive:true})); setVH();

  /* ===== Animated stars (Canvas) ===== */
  const canvas = $('#stars'), ctx = canvas.getContext('2d');
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vh'));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resizeCanvas(); addEventListener('resize', resizeCanvas, {passive:true});

  const stars = Array.from({length: 120}).map(()=>({
    x: Math.random()*innerWidth,
    y: Math.random()*innerHeight,
    r: Math.random()*1.5 + 0.3,
    s: Math.random()*0.3 + 0.05
  }));
  function drawStars(){
    ctx.clearRect(0,0,innerWidth,parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vh')));
    ctx.globalCompositeOperation='lighter';
    for(const st of stars){
      ctx.beginPath(); ctx.arc(st.x, st.y, st.r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(200,220,255,0.35)'; ctx.fill();
      st.y -= st.s; if(st.y < -2){ st.y = innerHeight+2; st.x = Math.random()*innerWidth; }
    }
    requestAnimationFrame(drawStars);
  }
  drawStars();

  /* ===== Camera to both panels ===== */
  const vidA = $('#vidA'), vidB = $('#vidB');
  let facing = 'user'; // or 'environment'
  let camStream = null;

  async function startCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode: { ideal: facing } }, audio:false
      });
      camStream = stream;
      // Use the SAME stream on both panels
      vidA.srcObject = stream; vidB.srcObject = stream;
      vidA.muted = true; vidB.muted = true;
      await Promise.allSettled([vidA.play(), vidB.play()]);
      setStatus('Camera running');
    }catch(e){ alert('Camera error: ' + (e?.message||e)); }
  }
  function stopCamera(){
    if(!camStream) return;
    camStream.getTracks().forEach(t=>t.stop());
    camStream = null;
    [vidA,vidB].forEach(v=>{ if(v.srcObject){ v.pause(); v.srcObject=null; }});
    setStatus('Camera stopped');
  }
  async function flipCamera(){
    facing = facing === 'user' ? 'environment' : 'user';
    if(camStream) { stopCamera(); await startCamera(); }
  }

  $('#startCam').addEventListener('click', startCamera);
  $('#stopCam').addEventListener('click', stopCamera);
  $('#flip').addEventListener('click', flipCamera);

  /* ===== Composited recording (background + both panels) =====
     We render the arena to a hidden canvas and captureStream() from it. */
  const recCanvas = document.createElement('canvas');
  const recCtx = recCanvas.getContext('2d');
  let recStream = null, recorder = null, chunks = [], rafId = null;

  function layoutSizes(){
    const W = innerWidth;
    const H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vh'));
    recCanvas.width = W; recCanvas.height = H;
    // panel rects (left/right halves)
    return { W, H, left:{x:0,y:0,w:W/2,h:H}, right:{x:W/2,y:0,w:W/2,h:H} };
  }

  function drawFrame(){
    const {W,H,left,right} = layoutSizes();
    // background gradient
    const g1 = recCtx.createRadialGradient(W/2, -220, 0, W/2, -220, 600);
    g1.addColorStop(0, 'rgba(255,255,255,0.06)'); g1.addColorStop(1, 'rgba(0,0,0,0)');
    recCtx.fillStyle = 'rgba(0,0,0,0.75)'; recCtx.fillRect(0,0,W,H);
    recCtx.globalCompositeOperation='lighter';
    recCtx.fillStyle = g1; recCtx.fillRect(0,0,W,H);
    recCtx.globalCompositeOperation='source-over';

    // draw camera into left & right (cover halves)
    if(vidA.srcObject){
      drawCoverVideo(recCtx, vidA, left.x, left.y, left.w, left.h);
      drawCoverVideo(recCtx, vidB, right.x, right.y, right.w, right.h);
    }
    // feather seam overlay
    const seam = recCtx.createLinearGradient(W/2-40,0,W/2+40,0);
    seam.addColorStop(0,'rgba(0,0,0,0)');
    seam.addColorStop(0.5,'rgba(255,255,255,0.18)');
    seam.addColorStop(1,'rgba(0,0,0,0)');
    recCtx.fillStyle = seam; recCtx.fillRect(W/2-40,0,80,H);

    // subtle scanlines
    recCtx.globalAlpha = 0.12;
    for(let y=0;y<H;y+=3){ recCtx.fillStyle='rgba(255,255,255,0.05)'; recCtx.fillRect(0,y,W,1); }
    recCtx.globalAlpha = 1;

    rafId = requestAnimationFrame(drawFrame);
  }

  function drawCoverVideo(ctx, video, x, y, w, h){
    const vw = video.videoWidth || 16, vh = video.videoHeight || 9;
    const vidAspect = vw / vh, boxAspect = w / h;
    let dw = w, dh = h, dx = x, dy = y;
    if(vidAspect > boxAspect){ // video wider than box
      dh = h; dw = dh * vidAspect; dx = x + (w - dw)/2;
    } else {
      dw = w; dh = dw / vidAspect; dy = y + (h - dh)/2;
    }
    ctx.drawImage(video, dx, dy, dw, dh);
  }

  function startRecording(){
    // Kick off compositor draw loop
    cancelAnimationFrame(rafId); drawFrame();
    recStream = recCanvas.captureStream(30); // 30fps
    chunks = [];
    const opts = { mimeType: 'video/webm;codecs=vp9' };
    try{
      recorder = new MediaRecorder(recStream, opts);
    }catch{
      recorder = new MediaRecorder(recStream); // fallback
    }
    recorder.ondataavailable = e=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
    recorder.onstop = saveRecording;
    recorder.start(200); // gather chunks
    $('#startRec').disabled = true; $('#stopRec').disabled = false;
    setStatus('Recording…');
  }
  function stopRecording(){
    if(recorder && recorder.state!=='inactive'){ recorder.stop(); }
    if(recStream){ recStream.getTracks().forEach(t=>t.stop()); recStream=null; }
    cancelAnimationFrame(rafId);
    $('#startRec').disabled = false; $('#stopRec').disabled = true;
    setStatus('Processing…');
  }
  function saveRecording(){
    const blob = new Blob(chunks, {type:'video/webm'});
    const url = URL.createObjectURL(blob);
    const a = $('#downloadLink');
    a.href = url; a.download = 'arena-recording.webm';
    a.style.display = 'inline-block';
    $('#recPreview').src = url; $('#recPreview').loop = true; $('#recPreview').play().catch(()=>{});
    setStatus('Saved');
  }

  $('#startRec').addEventListener('click', startRecording);
  $('#stopRec').addEventListener('click', stopRecording);

  function setStatus(s){ $('#recStatus').textContent = s; }

  // Start camera immediately if permission already granted (nice DX)
  (async () => {
    try{
      const perms = await navigator.permissions?.query?.({name:'camera'});
      if(perms && perms.state==='granted'){ startCamera(); }
    }catch{}
  })();
</script>
</body>
</html>
