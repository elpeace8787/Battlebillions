<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Arena — Galaxy + Person-Only (Fixed)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet"/>
<style>
  :root{ --vh:100svh; --ink:#f6f7fb; --bd:#ffffff24; --glass:rgba(255,255,255,.06); }
  *{ box-sizing:border-box }
  html,body{ margin:0; background:#07080c; color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif }
  header{ position:sticky; top:0; z-index:30; display:flex; gap:.5rem; align-items:center; padding:.6rem .8rem; background:rgba(10,11,16,.92); backdrop-filter:blur(8px); border-bottom:1px solid var(--bd) }
  .spacer{ flex:1 }
  .btn{ border:1px solid var(--bd); background:#151827; color:var(--ink); border-radius:12px; padding:.46rem .72rem; font-weight:800 }
  .btn.gold{ background:linear-gradient(180deg,#ffe88a,#ffc400); border:none; color:#141414 }
  .tag{ opacity:.85; font-weight:800 }
  .arena{ height:var(--vh); position:relative; overflow:hidden }
  #galaxy{ position:absolute; inset:0; z-index:0; display:block }
  .bgHue{ position:absolute; inset:-10% -10% 0 -10%; z-index:0; pointer-events:none;
    background:radial-gradient(1200px 520px at 50% -220px, rgba(255,255,255,.06), transparent 60%),
               radial-gradient(1000px 460px at 50% 115%, rgba(76,240,255,.08), transparent 60%),
               linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.75));
    animation:hue 28s linear infinite alternate }
  @keyframes hue{ from{ filter:hue-rotate(0deg) } to{ filter:hue-rotate(20deg) } }
  .scan{ position:absolute; inset:0; z-index:0; mix-blend-mode:soft-light; opacity:.16;
    background:repeating-linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, transparent 1px 3px) }
  .panes{ position:absolute; inset:0; display:grid; grid-template-columns:1fr 1fr; gap:0; z-index:1 }
  .pane{ position:relative; overflow:hidden }
  .pane.left  canvas{ -webkit-mask-image:linear-gradient(to right, black 0 86%, transparent 100%); mask-image:linear-gradient(to right, black 0 86%, transparent 100%) }
  .pane.right canvas{ -webkit-mask-image:linear-gradient(to left,  black 0 86%, transparent 100%); mask-image:linear-gradient(to left,  black 0 86%, transparent 100%) }
  .panes:after{ content:""; position:absolute; left:50%; top:0; bottom:0; width:3px; transform:translateX(-1.5px);
    background:linear-gradient(180deg, transparent, #ffffff22 20%, #8df0ff33 50%, transparent 80%); filter:blur(.5px); opacity:.75 }
  .center{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:2; display:grid; place-items:center; pointer-events:none }
  .hint{ background:var(--glass); border:1px solid var(--bd); padding:.5rem .7rem; border-radius:12px; font-weight:800 }
  .dock{ position:absolute; left:0; right:0; bottom:0; z-index:3; padding:.6rem .7rem calc(.7rem + env(safe-area-inset-bottom));
    background:linear-gradient(180deg, transparent 0%, rgba(8,8,10,.7) 22%, rgba(8,8,10,.95) 70%); border-top:1px solid var(--bd) }
  .row{ display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; justify-content:center }
  video#cam{ position:fixed; left:-9999px; top:-9999px; width:1px; height:1px; } /* hidden raw camera */
  .err{ position:fixed; left:50%; top:64px; transform:translateX(-50%); z-index:50; background:#ff2e6f; color:#fff; font-weight:800; padding:.5rem .7rem; border-radius:10px; display:none }
</style>
</head>
<body>
<header>
  <strong class="tag">ARENA • Galaxy 3D + Person Cutout</strong>
  <div class="spacer"></div>
  <button class="btn" id="flip">Flip Cam</button>
  <button class="btn" id="start">Start Camera</button>
  <button class="btn" id="stop" disabled>Stop</button>
  <button class="btn gold" id="record">Record 10s</button>
</header>

<div class="err" id="err"></div>

<section class="arena">
  <canvas id="galaxy"></canvas>
  <div class="bgHue"></div>
  <div class="scan"></div>

  <div class="panes">
    <div class="pane left"><canvas id="panelA"></canvas></div>
    <div class="pane right"><canvas id="panelB"></canvas></div>
  </div>

  <div class="center"><div class="hint">Start camera → we remove your background • you appear on both sides</div></div>

  <div class="dock">
    <div class="row"><span class="tag" style="opacity:.8">If you see no camera: load this file over HTTPS and allow camera access.</span></div>
  </div>
</section>

<video id="cam" playsinline muted></video>

<!-- MediaPipe (global) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<!-- Three.js (modules) -->
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
import { EffectComposer } from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass }     from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass }from 'https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/UnrealBloomPass.js';

const $ = s => document.querySelector(s);
const err = $('#err');

/* Viewport fix */
function setVH(){ const vv = window.visualViewport; document.documentElement.style.setProperty('--vh', Math.round(vv?.height||innerHeight)+'px'); }
['load','resize','orientationchange','scroll'].forEach(e=>addEventListener(e,setVH,{passive:true})); setVH();

/* ---------- Three.js Galaxy ---------- */
let renderer, scene, camera3D, stars, composer, bloom;
const galaxyCanvas = $('#galaxy');

function heightVH(){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--vh')) || innerHeight; }
function resizeGalaxy(){
  const w = innerWidth, h = heightVH();
  renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
  renderer.setSize(w,h,false);
  camera3D.aspect = w/h; camera3D.updateProjectionMatrix();
  composer.setSize(w,h); bloom.setSize(w,h);
}

function initGalaxy(){
  renderer = new THREE.WebGLRenderer({ canvas: galaxyCanvas, antialias:true, alpha:true });
  scene = new THREE.Scene();
  camera3D = new THREE.PerspectiveCamera(60, innerWidth/heightVH(), 0.1, 2000);
  camera3D.position.set(0,0,220);

  // Stars
  const starGeo = new THREE.BufferGeometry();
  const N = 4000;
  const positions = new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const r = 600 * Math.pow(Math.random(), .6);
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    positions[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
    positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
    positions[i*3+2] = r*Math.cos(phi);
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
  const starMat = new THREE.PointsMaterial({ color:0x9ecbff, size:1.2, sizeAttenuation:true, transparent:true, opacity:0.85, blending:THREE.AdditiveBlending });
  stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // Subtle nebula plane
  const fogGeo = new THREE.PlaneGeometry(2000,1200);
  const fogMat = new THREE.MeshBasicMaterial({ color:0x112233, transparent:true, opacity:0.25, blending:THREE.AdditiveBlending });
  const fog = new THREE.Mesh(fogGeo, fogMat);
  fog.position.z = -100;
  scene.add(fog);

  // Post
  const renderPass = new RenderPass(scene, camera3D);
  bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, heightVH()), 0.6, 0.8, 0.2);
  composer = new EffectComposer(renderer);
  composer.addPass(renderPass);
  composer.addPass(bloom);

  resizeGalaxy();
  animateGalaxy();
  setInterval(spawnExplosion, 1600 + Math.random()*1200);
}

function animateGalaxy(){
  requestAnimationFrame(animateGalaxy);
  const t = performance.now()*0.00006;
  stars.rotation.y = t*3;
  stars.rotation.x = Math.sin(t*0.6)*0.2;
  composer.render();
}

function spawnExplosion(){
  const group = new THREE.Group();
  const COUNT = 80;
  const pos = new Float32Array(COUNT*3);
  const vel = new Float32Array(COUNT*3);
  for(let i=0;i<COUNT;i++){
    pos[i*3+0]=0; pos[i*3+1]=0; pos[i*3+2]=0;
    const ang = Math.random()*Math.PI*2;
    const elev = (Math.random()-0.5)*0.6;
    const speed = 0.6 + Math.random()*1.8;
    vel[i*3+0] = Math.cos(ang)*speed;
    vel[i*3+1] = Math.sin(ang)*speed;
    vel[i*3+2] = elev*speed;
  }
  const pgeo = new THREE.BufferGeometry();
  pgeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  pgeo.setAttribute('velocity', new THREE.BufferAttribute(vel,3));
  const mat = new THREE.PointsMaterial({ color:0xff86b3, size:2.2, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending });
  const points = new THREE.Points(pgeo, mat);
  points.position.set((Math.random()-0.5)*280, (Math.random()-0.5)*160, -40 - Math.random()*80);
  group.add(points);
  scene.add(group);

  let life = 0;
  const updater = ()=>{
    life += 0.016;
    const p = pgeo.getAttribute('position');
    const v = pgeo.getAttribute('velocity');
    for(let i=0;i<p.count;i++){
      p.array[i*3+0] += v.array[i*3+0];
      p.array[i*3+1] += v.array[i*3+1];
      p.array[i*3+2] += v.array[i*3+2];
    }
    p.needsUpdate = true;
    mat.opacity = Math.max(0, 0.9 - life*1.2);
    if(life < 1.2) requestAnimationFrame(updater);
    else scene.remove(group);
  };
  updater();
}

addEventListener('resize', resizeGalaxy, {passive:true});

/* ---------- MediaPipe Selfie Segmentation (global) ---------- */
const camEl = $('#cam');
let facing = 'user', camStream = null, running = false, rafId = null;

const panelA = $('#panelA'), panelB = $('#panelB');
const ctxA = panelA.getContext('2d'), ctxB = panelB.getContext('2d');

function sizePanels(){
  const W = innerWidth, H = heightVH();
  panelA.width = Math.floor(W/2); panelA.height = H;
  panelB.width = Math.floor(W/2); panelB.height = H;
}
sizePanels(); addEventListener('resize', sizePanels, {passive:true});

const segmenter = new window.SelfieSegmentation.SelfieSegmentation({
  locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`
});
segmenter.setOptions({ modelSelection: 1 });
segmenter.onResults(onSegResults);

function drawCover(ctx, source, x, y, w, h){
  const sw = source.videoWidth || source.width || 16;
  const sh = source.videoHeight|| source.height|| 9;
  const sAspect = sw/sh, dAspect = w/h;
  let dw=w, dh=h, dx=x, dy=y;
  if(sAspect > dAspect){ dh = h; dw = dh*sAspect; dx = x + (w - dw)/2; }
  else { dw = w; dh = dw/sAspect; dy = y + (h - dh)/2; }
  ctx.clearRect(x,y,w,h);
  ctx.drawImage(source, dx, dy, dw, dh);
}

const personCanvas = document.createElement('canvas');
const personCtx = personCanvas.getContext('2d');

function onSegResults(results){
  const W = innerWidth, H = heightVH();
  personCanvas.width = W; personCanvas.height = H;

  // mask to keep person only
  personCtx.clearRect(0,0,W,H);
  personCtx.save();
  personCtx.drawImage(results.segmentationMask, 0, 0, W, H);
  personCtx.globalCompositeOperation = 'source-in';
  drawCover(personCtx, camEl, 0, 0, W, H);
  personCtx.restore();

  drawCover(ctxA, personCanvas, 0, 0, panelA.width, panelA.height);
  drawCover(ctxB, personCanvas, 0, 0, panelB.width, panelB.height);
}

async function startCamera(){
  try{
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      throw new Error('Camera requires HTTPS. Use a secure URL or localhost.');
    }
    camStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode: { ideal: facing } }, audio:false });
    camEl.srcObject = camStream; camEl.muted = true;
    await camEl.play();
    running = true; loop();
    $('#start').disabled = true; $('#stop').disabled = false;
    showErr('');
  }catch(e){
    showErr(e?.message || 'Camera failed. Check HTTPS and permissions.');
  }
}
function stopCamera(){
  running = false;
  if(rafId) cancelAnimationFrame(rafId);
  if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream = null; }
  camEl.pause(); camEl.srcObject = null;
  ctxA.clearRect(0,0,panelA.width,panelA.height);
  ctxB.clearRect(0,0,panelB.width,panelB.height);
  $('#start').disabled = false; $('#stop').disabled = true;
}

async function flipCamera(){
  facing = (facing==='user' ? 'environment' : 'user');
  if(camStream){ stopCamera(); await startCamera(); }
}

let lastSent = 0;
async function loop(){
  if(!running) return;
  const now = performance.now();
  if(now - lastSent > 33){ lastSent = now; await segmenter.send({ image: camEl }); }
  rafId = requestAnimationFrame(loop);
}

/* ---------- 10s Recording of the whole arena ---------- */
$('#record').addEventListener('click', async ()=>{
  const recCanvas = document.createElement('canvas');
  recCanvas.width = innerWidth; recCanvas.height = heightVH();
  const rctx = recCanvas.getContext('2d');

  let t=0; const draw = ()=>{
    const W=recCanvas.width, H=recCanvas.height;
    rctx.clearRect(0,0,W,H);
    rctx.drawImage(galaxyCanvas, 0,0,W,H);
    rctx.drawImage(panelA, 0,0, W/2, H);
    rctx.drawImage(panelB, W/2,0, W/2, H);
    const g = rctx.createLinearGradient(W/2-40,0,W/2+40,0);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(.5,'rgba(255,255,255,.18)'); g.addColorStop(1,'rgba(0,0,0,0)');
    rctx.fillStyle=g; rctx.fillRect(W/2-40,0,80,H);
    t=requestAnimationFrame(draw);
  };
  draw();

  const stream = recCanvas.captureStream(30);
  let chunks=[];
  const rec = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'});
  rec.ondataavailable = e => { if(e.data.size) chunks.push(e.data); };
  rec.onstop = ()=>{
    cancelAnimationFrame(t);
    const blob = new Blob(chunks,{type:'video/webm'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='arena-galaxy-person.webm'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  };
  rec.start(200);
  setTimeout(()=> rec.state!=='inactive' && rec.stop(), 10000);
});

/* ---------- UI ---------- */
$('#start').addEventListener('click', startCamera);
$('#stop').addEventListener('click', stopCamera);
$('#flip').addEventListener('click', flipCamera);

/* Boot galaxy immediately */
initGalaxy();

/* Auto-start camera if already granted */
try{
  const p = await navigator.permissions?.query?.({name:'camera'});
  if(p && p.state==='granted') startCamera();
}catch{}

/* helpers */
function showErr(msg){ err.textContent = msg; err.style.display = msg ? 'block' : 'none'; }
</script>
</body>
</html>
